\documentclass[paper.tex]{subfiles}
\begin{document}

\section{Synthesis in \casio}

At a high level, \casio translates mathematical \emph{formulas}
  into floating-point \emph{programs}.
\casio translates using a heuristic search algorithm
  that attempts to find a sequence of changes
  that produces the largest improvement in precision.
Unlike conventional compilers,
  \casio is free to translate while changing
  the semantics of the translated program.

\subsection{Constraints on \casio}

Though \casio can change the answer produced by a program,
  it is not free to return arbitrary answers.
The main constraint on \casio
  is that, \emph{viewed as a real-number formula},
  the output of \casio must equal its input.
We can formalize this notion by defining
  two semantics for mathematical expressions:
  a real-number semantics,
  where each constant and variable is a real number
  and each operator a function from reals to reals;
  and a floating-point semantics,
  where each constant and variable is truncated
  to a floating-point number
  and where each function is replaced by its floating-point version.
Then we may require that \casio's transformations
  must preserve the real-number semantics of programs,
  though it may change their floating-point semantics.

In fact, this constraint is too strong,
  as it prevents transformations that change
  the region a program is defined on.
For example, output of the transformation
\[
  x + y \leadsto \frac{x^2 - y^2}{x - y}
\]
  is equal to its input, except where $x = y$.
For that particular input, the output program is not defined.
To allow this class of transformations,
  which can greatly improve the precision of a program,
  we require that the output program
  only equal the input program where both are defined.
We calls programs that are equal they are defined \emph{real-equivalent} programs.

This constraint that \casio only outputs real-equivalent programs
  influences \casio's architecture.
Since \casio must not change the real-number semantics of programs
  (except by changing where the program is defined),
  it is natural to structure \casio
  as applying a sequence of rewrite rules,
  each of which satisfy the above property.
These rules are specified by pattern matching;
  for example, the transformation above is a rule,
  with $x$ and $y$ matching arbitrary subexpressions.
\casio contains 109 rules,
  including those for
  the commutativity, associativity, distributivity, and identity
  of basic arithmetic operators;
  fraction arithmetic;
  laws of squares, square roots, exponents, and logarithms;
  and some basic facts of trigonometry.
Each of these rules is a basic fact of algebra;
  it incorporates no understanding of numerical methods.
In preparing the rules,
  care was taken to ensure that rules
  do not change the real-number semantics of programs.
This was usually easy, but required some care
  to avoid false ``identities'' such as $\sqrt{x^2} = x$
  (this identity being false for negative $x$).

The simplest method for improving precision
  would be to apply these rewrite rules at random,
  keeping more-precise variants.
This method does not work.
Too much time is spent on rewrites
  that have no effect on program precision.
Often, multiple rewrites without any effect
  are necessary to enable a rewrite that significantly improves precision.
The simplistic random-rewrite approach struggles with these cases.
To improve precision, important subexpressions
  must be found and focused on.

  \todo{Evaluating programs by sample points}

  \todo{Measuring error with floats-between}

  \todo{Main loop}

\subsection{Focusing with local error}

\casio must focus on those expressions
  where a rewrite will effect the largest improvement in precision.
This measure must be approximated.
By looking at the error of each expression,
  \casio can determine which expressions
  have the most room for improvement.
However, expressions where children have high error
  usually have high error themselves by
  the garbage-in garbage-out principle.
To avoid biasing \casio's focusing algorithm
  toward larger expressions, \casio focuses
  based not on error, but on \emph{local error}.
Local error is defined at each operator
  as the error between
  the exact operator, applied to exactly-evaluated inputs
  and the inexact operator, applied to exactly-evaluated inputs;
  see Algorithm~\ref{alg:focus}.
By exactly evaluating inputs,
  \casio avoids penalizing the output of operators
  for errors in computing their inputs.

\casio computes the local error of every operator at every sample point,
  and chooses to focus on the three expressions
  whose operators have the highest local error.
In many cases, this leads \casio to precisely the correct location
  to apply a rewrite.
For example, consider the program $\sqrt{x+1} - \sqrt{x}$.
This program is imprecise when $x$ is large,
  because $\sqrt{x+1}$ and $\sqrt{x}$ are large and close-by,
  causing cancellation error.
For large inputs, both $\sqrt{x+1}$ and $\sqrt{x}$
  are computed with little error.
However, the subtraction, even with exact inputs,
  produces large errors due to cancellation.
Thus, the subtraction operator has high local error,
  while the other operators have very low error.
As a result, \casio easily finds the correct location
  to rewrite this program.

\subsection{Recursive rewrite pattern matching}

After an expression is focused upon,
  \casio must determine how to rewrite that expression.
A common problem is that an expression may require multiple rewrites
  to enable a rewrite that actually improves precision.
For example, consider the expression
\[
 \left(\frac{1}{x-1} - \frac{2}{x} \right) + \frac{1}{x+1}.
\]
\casio correctly identifies the $(+)$ operator
  to have the most local error (due to cancellation).
To improve the precision of this program,
  all of the fractions must be placed under a common denominator,
  and then the numerator must be simplified.
\casio has rules for fraction addition and subtraction;
  however, doing a single fraction addition or subtraction
  does not significantly change the precision of the program,
  since precision loss is caused by a cancellation
  that occurs when \emph{all} values are added together.
In order to improve the precision of this program,
  \casio must use the fraction addition/subtraction rules twice:
  once on the parenthesized subtraction,
  then again for the remaining addition.
Note that the first rewrite occurs not at the focused-upon operator,
  but on a child expression; however, this rewrite
  is necessary for enabling the later rewrite.

\casio uses a special pattern-matching algorithm
  to automatically find and solve instances like the above,
  where subexpressions must be rewritten
  to allow a rewrite of the parent expression.
Pseudo-code for this algorithm is sketched in Algorithm~\ref{alg:rm}.
This matching algorithm, which we call recursive rewrite pattern matching,
  allows \casio to automatically derive
  stretches of \todo{How many} rewrites at once.
\casio uses recursive-rewrite pattern matching
  after focusing on an expression.

\subsection{Regime inference}

Often two real-equivalent programs have incomparable precision---%
  one performs better on some inputs, but worse on others.
A striking example of this phenomenon occurs with the expression $(e^x - 1) / x$.
The best program real-equivalent to the above
  uses the three implementations
\begin{align*}
  \frac{e^x - 1}{x} & \frac{e^x - 1}{\log e^x} &
  \frac{e^x}{x} - \frac1x & \frac{e^x - 1}{\sqrt{x}^2} 
\end{align*}
  each for different ranges of values for the variable $x$.
\casio must automatically infer the regimes
  into which the input subdivides,
  and must choose which programs to run on each region.
In doing this, \casio must not add too many branches,
  since each branch is computationally expensive.

\casio infers regimes using a dynamic programming algorithm.
First, \casio chooses a variable to infer regimes on
  (that is, regime inference works on one dimension at a time).
Then, it computes the best set of at most $k$ regimes
  for the region $(-\infty, t)$, where $t$ is a sampled point,
  with regimes $(t_0, t_1)$ evaluated by their total error
  in the region $t_0 < x < t_1$.
This is computed iteratively in $k$;
  to find the best set of up to $k$ regimes,
  for each possible $t_1$, each possible $t_0$ is considered,
  each regime $(t_0, t_1)$ is considered,
  and the best is added on to the best set of up to $k-1$ regimes
  (see Algorithm~\ref{sec:regimes}).
This algorithm runs in $O(n^2 k c)$ time,
  where $n$ is the number of points,
  $k$ is the maximum number of regimes,
  and $c$ is the number of candidate programs.
We have found this to be sufficiently fast;
  this algorithm produces the optimal set of up to $k$ regimes.
\casio caps $k$ at 5.
Regime endpoints are chosen to be between sampled points;
  to determine where exactly the split point between regimes should go,
  \casio uses a binary search on that variable.

This regimes algorithm finds regimes that improve
  the precision of many of \casio's inputs.
Sometimes, like in the above example,
  finding many regimes is necessary to achieve significant improvement
  in precision.
However, regimes can also produce mild improvement
  that has not, to our knowledge, been noticed before.
For example, in the $\sqrt{x+1} - \sqrt{x}$ example mentioned above,
  \casio produces the more precise program
\[
\frac{1}{\sqrt{x+1} + \sqrt{x}}
\]
  but only uses it for values of $x$ greater than approximately $0.002$.
The original program turns out to be superior for smaller input values,
  though both programs are very accurate and the improvement is slight.
\casio's regime inference automatically notices this fact
  and generates an accurate branch condition.

\subsection{Correlated Error}

\casio's focusing mechanism usually correctly detects
  the best expression to rewrite.
However, it is based on an assumption:
  that the way to improve the precision of a program
  is to improve the precision of each expression in it.
This assumption ignores the possibility
  that two expressions could both have error,
  but error that correlates and somehow cancels
  when the two expressions are combined.
A case where this occurs is the formula $(e^x - 1) / x$.
This formula is inaccurate for $x$ near $0$,
  because cancellation occurs in $e^x - 1$.
However, if the denominator is transformed from $x$ into $\log e^x$,
  the same cancellation will occur in the denominator,
  leading to a result of approximately $1$, which is correct.

To support this type of precision optimization,
  \casio will, after the main rewrite loop is complete,
  find all remaining expressions with error,
  and try rewrite sibling expressions, siblings of parents, and so on.
This produces many candidates, but since it is done only once
  and after the main rewrite loop is complete, the cost is small.
We've found this optimization to be useful in only a small number of cases.

\end{document}
