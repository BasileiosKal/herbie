\documentclass[paper.tex]{subfiles}
\begin{document}

\section{Synthesis in \casio}

At a high level, \casio translates mathematical \emph{formulas}
  into floating-point \emph{programs}.
\casio translates using a heuristic search algorithm
  that attempts to find a sequence of changes
  that produces the largest improvement in precision.
Unlike conventional compilers,
  \casio is free to translate while changing
  the semantics of the translated program.

\subsection{Constraints on \casio}

Though \casio can change the answer produced by a program,
  it is not free to return arbitrary answers.
The main constraint on \casio
  is that, \emph{viewed as a real-number formula},
  the output of \casio must equal its input.
We can formalize this notion by defining
  two semantics for mathematical expressions:
  a real-number semantics,
  where each constant and variable is a real number
  and each operator a function from reals to reals;
  and a floating-point semantics,
  where each constant and variable is truncated
  to a floating-point number
  and where each function is replaced by its floating-point version.
Then we may require that \casio's transformations
  must preserve the real-number semantics of programs,
  though it may change their floating-point semantics.

In fact, this constraint is too strong,
  as it prevents transformations that change
  the region a program is defined on.
For example, output of the transformation
\[
  x + y \leadsto \frac{x^2 - y^2}{x - y}
\]
  is equal to its input, except where $x = y$.
For that particular input, the output program is not defined.
To allow this class of transformations,
  which can greatly improve the precision of a program,
  we require that the output program
  only equal the input program where both are defined.
We calls programs that are equal they are defined \emph{real-equivalent} programs.

This constraint that \casio only outputs real-equivalent programs
  influences \casio's architecture.
Since \casio must not change the real-number semantics of programs
  (except by changing where the program is defined),
  it is natural to structure \casio
  as applying a sequence of rewrite rules,
  each of which satisfy the above property.
These rules are specified by pattern matching;
  for example, the transformation above is a rule,
  with $x$ and $y$ matching arbitrary subexpressions.
\casio contains 109 rules,
  including those for
  the commutativity, associativity, distributivity, and identity
  of basic arithmetic operators;
  fraction arithmetic;
  laws of squares, square roots, exponents, and logarithms;
  and some basic facts of trigonometry.
Each of these rules is a basic fact of algebra;
  it incorporates no understanding of numerical methods.
In preparing the rules,
  care was taken to ensure that rules
  do not change the real-number semantics of programs.
This was usually easy, but required some care
  to avoid false ``identities'' such as $\sqrt{x^2} = x$
  (this identity being false for negative $x$).

The simplest method for improving precision
  would be to apply these rewrite rules at random,
  keeping more-precise variants.
This method does not work.
Too much time is spent on rewrites
  that have no effect on program precision.
Often, multiple rewrites without any effect
  are necessary to enable a rewrite that significantly improves precision.
The simplistic random-rewrite approach struggles with these cases.
To improve precision, important subexpressions
  must be found and focused on.

\casio's core is a simple loop
  which threads together several techniques described below.
The loop tracks a single program,
  real-equivalent to the input program.
In each iteration, \casio generates candidates
  by focusing on the expressions where a rewrite
  will lead to the biggest improvement;
  applying a sequence of rewrites to that expression;
  and simplifying the result.
Then the best candidate is chosen for the next iteration.
Before entering the main loop,
  \casio analyzes the program for periodic subexpressions
  and attempts to optimize them separately.
After the main loop completes,
  \casio aggregates all candidates generated
  throughout the course of the loop,
  and infers branch conditions
  to execute different candidates for different inputs.
These techniques, combined, are \casio.

\todo{Filter by best-at-point}

\subsection{Evaluating error of expressions}

As \casio discovers and applies rewrites,
  it needs to know if it is improving precision.
This can be done statically using interval~\cite{} or affine arithmetic~\cite{},
  or using an SMT solver to get tighter bounds~\cite{}.
However, affine and interval arithmetic give
  very conservative estimates of error~\cite{},
  and SMT techniques are slow.
Instead, \casio estimates error by simply sampling many possible inputs
  and computing the average difference between a floating-point
  and arbitrary-precision evaluation on those points.
Arbitrary-precision arithmetic is slow,
  so arbitrary-precision results are computed only once per run;
  each rewrite need only be evaluated in floating-point
  and compared to the already-computed arbitrary-precision results.
\casio selects 500 points, distributed approximately uniformly
  over the \emph{set} of floating-point numbers
  (this leads to a near-uniform distribution over the exponent).
Experiments show that the estimate computed from 500 points
  is rarely more than one bit of error removed from the true answer.

Once sample points are chosen
  and exact and floating-point answers are computed,
  some measure of error is necessary to compare the two.
Mathematically-natural measures include absolute and relative error.
However, both of these measures are ill-suited
  to measuring error between floating-point values~\cite{}.
We follow \textsc{Stoke}~\cite{} in defining the error between $x$ and $y$
  by the number of floating-point values in the range $[x, y]$.
This measure of error is uniform over the input space,
  avoiding problems with denormal floating-point values,
  and avoiding any special handling for infinities.

\subsection{Focusing with local error}

\casio must focus on those expressions
  where a rewrite will effect the largest improvement in precision.
This measure must be approximated.
By looking at the error of each expression,
  \casio can determine which expressions
  have the most room for improvement.
However, expressions where children have high error
  usually have high error themselves by
  the garbage-in garbage-out principle.
To avoid biasing \casio's focusing algorithm
  toward larger expressions, \casio focuses
  based not on error, but on \emph{local error}.
Local error is defined at each operator
  as the error between
  the exact operator, applied to exactly-evaluated inputs
  and the inexact operator, applied to exactly-evaluated inputs;
  see Algorithm~\ref{alg:focus}.
By exactly evaluating inputs,
  \casio avoids penalizing the output of operators
  for errors in computing their inputs.

\casio computes the local error of every operator at every sample point,
  and chooses to focus on the three expressions
  whose operators have the highest local error.
In many cases, this leads \casio to precisely the correct location
  to apply a rewrite.
For example, consider the program $\sqrt{x+1} - \sqrt{x}$.
This program is imprecise when $x$ is large,
  because $\sqrt{x+1}$ and $\sqrt{x}$ are large and close-by,
  causing cancellation error.
For large inputs, both $\sqrt{x+1}$ and $\sqrt{x}$
  are computed with little error.
However, the subtraction, even with exact inputs,
  produces large errors due to cancellation.
Thus, the subtraction operator has high local error,
  while the other operators have very low error.
As a result, \casio easily finds the correct location
  to rewrite this program.

\subsection{Recursive rewrite pattern matching}

After an expression is focused upon,
  \casio must determine how to rewrite that expression.
A common problem is that an expression may require multiple rewrites
  to enable a rewrite that actually improves precision.
For example, consider the expression
\[
 \left(\frac{1}{x-1} - \frac{2}{x} \right) + \frac{1}{x+1}.
\]
\casio correctly identifies the $(+)$ operator
  to have the most local error (due to cancellation).
To improve the precision of this program,
  all of the fractions must be placed under a common denominator,
  and then the numerator must be simplified.
\casio has rules for fraction addition and subtraction;
  however, doing a single fraction addition or subtraction
  does not significantly change the precision of the program,
  since precision loss is caused by a cancellation
  that occurs when \emph{all} values are added together.
In order to improve the precision of this program,
  \casio must use the fraction addition/subtraction rules twice:
  once on the parenthesized subtraction,
  then again for the remaining addition.
Note that the first rewrite occurs not at the focused-upon operator,
  but on a child expression; however, this rewrite
  is necessary for enabling the later rewrite.

\casio uses a special pattern-matching algorithm
  to automatically find and solve instances like the above,
  where subexpressions must be rewritten
  to allow a rewrite of the parent expression.
Pseudo-code for this algorithm is sketched in Algorithm~\ref{alg:rm}.
This matching algorithm, which we call recursive rewrite pattern matching,
  allows \casio to automatically derive
  stretches of \todo{How many} rewrites at once.
\casio uses recursive-rewrite pattern matching
  after focusing on an expression.

\subsection{Simplification}

\todo{Simplification}

\subsection{Regime inference}

Often two real-equivalent programs have incomparable precision---%
  one performs better on some inputs, but worse on others.
A striking example of this phenomenon occurs with the expression $(e^x - 1) / x$.
The best program real-equivalent to the above
  uses the three implementations
\begin{align*}
  \frac{e^x - 1}{x} & \frac{e^x - 1}{\log e^x} &
  \frac{e^x}{x} - \frac1x & \frac{e^x - 1}{\sqrt{x}^2} 
\end{align*}
  each for different ranges of values for the variable $x$.
\casio must automatically infer the regimes
  into which the input subdivides,
  and must choose which programs to run on each region.
In doing this, \casio must not add too many branches,
  since each branch is computationally expensive.

\casio infers regimes using a dynamic programming algorithm.
First, \casio chooses a variable to infer regimes on
  (that is, regime inference works on one dimension at a time).
Then, it computes the best set of at most $k$ regimes
  for the region $(-\infty, t)$, where $t$ is a sampled point,
  with regimes $(t_0, t_1)$ evaluated by their total error
  in the region $t_0 < x < t_1$.
This is computed iteratively in $k$;
  to find the best set of up to $k$ regimes,
  for each possible $t_1$, each possible $t_0$ is considered,
  each regime $(t_0, t_1)$ is considered,
  and the best is added on to the best set of up to $k-1$ regimes
  (see Algorithm~\ref{sec:regimes}).
This algorithm runs in $O(n^2 k c)$ time,
  where $n$ is the number of points,
  $k$ is the maximum number of regimes,
  and $c$ is the number of candidate programs.
We have found this to be sufficiently fast;
  this algorithm produces the optimal set of up to $k$ regimes.
\casio caps $k$ at 5.
Regime endpoints are chosen to be between sampled points;
  to determine where exactly the split point between regimes should go,
  \casio uses a binary search on that variable.

This regimes algorithm finds regimes that improve
  the precision of many of \casio's inputs.
Sometimes, like in the above example,
  finding many regimes is necessary to achieve significant improvement
  in precision.
However, regimes can also produce mild improvement
  that has not, to our knowledge, been noticed before.
For example, in the $\sqrt{x+1} - \sqrt{x}$ example mentioned above,
  \casio produces the more precise program
\[
\frac{1}{\sqrt{x+1} + \sqrt{x}}
\]
  but only uses it for values of $x$ greater than approximately $0.002$.
The original program turns out to be superior for smaller input values,
  though both programs are very accurate and the improvement is slight.
\casio's regime inference automatically notices this fact
  and generates an accurate branch condition.

\subsection{Periodic Functions}

Regimes inference works well when the regimes
  are large contiguous ranges in a variable.
Periodic functions, on the other hand, often require periodic regimes.
For example, the two real-equivalent formulas
\[
\frac{1 - \cos x}{\sin x} = \frac{\sin x}{1 + \cos x}
\]
  need regimes, wherein the second will be used
  near even multiples of $\pi$, and the first near odd multiples.
Regime inference cannot infer such regimes; furthermore,
  periodic functions can be evaluated more accurately
  if they are evaluated on points uniformly sampled in their period.
For these two reasons, \casio uses a static analysis
  to detect periodic functions, and analyze them specially.

To detect periodic functions, \casio uses an abstract interpretation,
  where each expression is classified as
  a constant (of known value); a linear function (of known coefficients);
  a periodic function (of known period); or a general function.
Addition, subtraction, multiplication, and division
  combine linear functions with each other or with constants
  into linear functions.
Trigonometric functions turn linear arguments
  into periodic outputs.
And any expression whose arguments are periodic
  is itself periodic, where the period is computed
  by taking the least common multiple of the periods of all children.
Expressions whose arguments include
  both periodic and non-periodic expressions
  are placed in the general class.
This analysis is conservative; for example, the period of $(\sin x)^2$
  is computed as $2 \pi$, whereas in fact it is $\pi$.
However, every expression that it declares as periodic
  is in fact periodic with the given period.

Once periodic functions have been found,
  \casio extracts the largest periodic expressions
  and executes a full \casio run on each expression,
  with points chosen uniformly on $[0, t)$,
  where $t$ is the period.
If the resulting program includes branches introduced by regimes,
  the condition in each branch is changed via the substitution
  $x \mapsto \mathsf{mod}(x, t)$, for each variable $x$ with period $t$.
The body of the branch is not changed,
  because for large inputs, expressions like
  $\sin \mathsf{mod}(x, 2\pi)$
  are less accurate than the real-equivalent $\sin x$.

\subsection{Correlated Error}

\casio's focusing mechanism usually correctly detects
  the best expression to rewrite.
However, it is based on an assumption:
  that the way to improve the precision of a program
  is to improve the precision of each expression in it.
This assumption ignores the possibility
  that two expressions could both have error,
  but error that correlates and somehow cancels
  when the two expressions are combined.
A case where this occurs is the formula $(e^x - 1) / x$.
This formula is inaccurate for $x$ near $0$,
  because cancellation occurs in $e^x - 1$.
However, if the denominator is transformed from $x$ into $\log e^x$,
  the same cancellation will occur in the denominator,
  leading to a result of approximately $1$, which is correct.

To support this type of precision optimization,
  \casio will, after the main rewrite loop is complete,
  find all remaining expressions with error,
  and try rewrite sibling expressions, siblings of parents, and so on.
This produces many candidates, but since it is done only once
  and after the main rewrite loop is complete, the cost is small.
We've found this optimization to be useful in only a small number of cases.

\end{document}
