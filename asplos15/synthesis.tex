\documentclass[paper.tex]{subfiles}
\begin{document}

\section{Improving Accuracy with  \casio}
\label{sec:synthesis}

\casio improve accuracy using a heuristic search that attempts to find
a sequence of changes that produce the largest improvement in
accuracy.  Unlike conventional compilers, \casio is free to translate
while changing the semantics of the translated program.

\subsection{Constraints on \casio}

Because we sample, we require soundness over reals.

Though \casio can change the answer produced by a program,
  it is not free to return arbitrary answers.
The main constraint on \casio
  is that, \emph{viewed as a real-number formula},
  the output of \casio must equal its input.
We can formalize this notion by defining
  two semantics for mathematical expressions:
  a real-number semantics,
  where each constant and variable is a real number
  and each operator a function from reals to reals;
  and a floating-point semantics,
  where each constant and variable is truncated
  to a floating-point number
  and where each function is replaced by its floating-point version.
Then we may require that \casio's transformations
  must preserve the real-number semantics of programs,
  though it may change their floating-point semantics.

We slightly relax this constraint,
  as it prevents transformations that change
  the region a program is defined on.
For example, output of the transformation
\[
  x + y \leadsto \frac{x^2 - y^2}{x - y}
\]
  is equal to its input, except where $x = y$.
For that particular input, the output program is not defined.
To allow this class of transformations,
  which can greatly improve the accuracy of a program,
  we require that the output program
  only equal the input program where both are defined.
We call programs that are equal they are defined \emph{real-equivalent} programs.

Since \casio must not change the real-number semantics of programs
  (except by changing where the program is defined),
  it is natural to structure \casio
  as applying a sequence of rewrite rules,
  each of which preserve real equivalence.
These rules are specified as input and output patterns;
  for example, the transformation above is a rule,
  with $x$ and $y$ matching arbitrary subexpressions.
\casio contains \nRewrites rules,
  including those for
  the commutativity, associativity, distributivity, and identity
  of basic arithmetic operators;
  fraction arithmetic;
  laws of squares, square roots, exponents, and logarithms;
  and some basic facts of trigonometry.

Each of these rules is a basic fact of algebra;
  it incorporates no understanding of numerical methods.
In preparing the rules,
  care was taken to ensure that rules
  do not change the real-number semantics of programs.
This was usually easy, but required some care
  to avoid false ``identities'' such as $\sqrt{x^2} = x$
  (this identity being false for negative $x$).

The simplest, most obvious approach to a rewrite based system
  is a hill-climbing brute force search,
  where one applies rewrite rules at random,
  keeping the transformations where error behavior is improved.
Unfortunately, this method is not effective:
  too much time is spent on rewrites
  that have no effect on program accuracy,
  and sequences of rewrites that would improve accuracy
  are often not found, since intermediary steps do not neccessarily improve error.

Often, multiple rewrites without any effect
  are necessary to enable a rewrite that significantly improves accuracy.
Sometimes, even after the correct rewrite is found,
  terms need to be canceled before accuracy is gained.
The simplistic random-rewrite approach struggles with these cases.
To improve accuracy, important subexpressions
  must be found and focused on;
  sequences of rewrites need to be considered as a unit;
  and cancellation needs to occur automatically.

\casio's core is a simple loop
  which threads together several rewrite techniques,
  each described below.
The loop tracks a set of \emph{alternatives},
  program variants each real-equivalent to the input.
This set of alternatives only contains
  programs that have the lowest error on at least one point
  of all candidate programs generated so far.
In each iteration, \casio generates new candidates
  by choosing one alternative that has not been chosen before;
  finding expressions where a rewrite may lead to improvement;
  selecting the rewrite-rules which match the error-causing operator
  and applying a sequence of rewrites to enable the application of that rule;
  and simplifying the result, canceling like terms.
Then the best candidate is chosen for the next iteration.
Before entering the main loop,
  \casio analyzes the program for periodic subexpressions
  and attempts to optimize them separately.
After the main loop completes,
  \casio aggregates all candidates generated
  throughout the course of the loop,
  and infers regimes of input values for which
  to execute different candidates.

\begin{figure}
\begin{footnotesize}
\begin{align*}
  \|casio|&(e) \ceq \\
  & pts, exs \ceq \|pickPoints|(e) \\
  & e' \ceq \|simplify|(e) \\
  & e'' \ceq \|mapPeriod|(e') \\
  & t \ceq \|makeTable|(e'') \\
  & \|while|(\|not| \; t.\|done|) \\
  & \;\;\;\; e, t' \ceq \|pick|\;t \\
  & \;\;\;\; es \ceq \|map|\:\|simplify|\:(\|map|\:\|rr|\:(\|focus|\;e)) \\
  & \|regimes|\:(\cup\{\|uncorrelated|\;e \I e \in t \})
\end{align*}
\end{footnotesize}
\caption{\todo{caption}}
\end{figure}

\subsection{Evaluating error of expressions}

As \casio discovers and applies rewrites,
  it needs to know if it is improving accuracy.
This can be done statically using interval~\cite{} or affine arithmetic~\cite{},
  or using an SMT solver to get tighter bounds~\cite{}.
However, affine and interval arithmetic give
  very conservative estimates of error~\cite{},
  and current SMT solver based techniques impose significant overhead.
Instead, \casio estimates error by simply sampling many possible inputs
  and computing the average difference between a floating-point
  and arbitrary-precision evaluation on those points.
Arbitrary-precision arithmetic is slow,
  so arbitrary-precision results are computed only once per run;
  each rewrite need only be evaluated in floating-point
  and compared to the already-computed arbitrary-precision results.
\casio selects \nSample points, distributed approximately uniformly
  over the \emph{set} of floating-point numbers
  (this leads to a near-uniform distribution over the exponent).
While it may seem intuitive to instead select points
  distributed near-uniform over the reals instead,
  there are several problems with this approach:
firstly, we found during evaluation
  that distributing uniformly across the reals
  yields only points of the upper two or three orders of magnitude,
  which for some functions produces results
  that are unilaterally out of bounds of floating points;
secondly, even for functions that have reasonable results for large input values,
  sampling only these large exponents yields to a misrepresentative error evaluation.
Experiments show that the estimate computed from 500 points
  is rarely more than one bit of error removed from the true answer.

  Once sample points are chosen and exact and floating-point answers
  are computed, some measure of error is necessary to compare the two.
  Mathematically-natural measures include absolute and relative error.
  However, both of these measures are ill-suited to measuring error
  between floating-point values~\cite{}.  We follow
  \textsc{Stoke}~\cite{} in defining the error between $x$ and $y$ by
  the number of floating-point values in the range $[x, y]$.  This
  measure of error is uniform over the input space, avoiding problems
  with denormal floating-point values, and avoiding any special
  handling for infinities.  Casio evaluates the input program in
  arbitrary precision at every sample point, and cast the result to
  floating point; \casio considers this the exact solution.  Any
  candidate program can then be evaluated in floating point and
  compared to the exact solution at that point, to compute the
  candidate program's error at that point.

\begin{figure}
\begin{align*}
  \FP_{64}, \FP_\infty &: \|FloatingPointSystem| \\
  \Err &\:x\:y \ceq \#\{ z : \FP_{64}\:|\:x \le z \le y \} \\
  \\
  \Var &\ceq \{ x, y, z, \dotsc \} \\
  \Op &\ceq \{ \|exp|, \|pow|, \|log|, \dotsc \} \\
  \Expr &\ceq c \I x \I f(e_1, \dotsc, e_k) \\
  & c : \RR, x : \Var, f : \Op, e_i : \Expr \\
  \|eval|_t &: (\Var \to \RR) \to \Expr \to \FP_t
\end{align*}
\caption{Common variables. $\FP_{64}$ and $\FP_\infty$ represent
  the types of 64-bit floating point and arbitrary-precision values.
  $\Err$ measures the error between two real values
  as the number of floating point values between them.
  $\Expr$ represents the type of mathematical expressions,
  and $\|eval|_t$ evaluates expressions in $\FP_t$ arithmetic.}
\label{alg:defs}
\end{figure}

\subsection{Focusing with local error}

In order to most effectively apply rewrites that reduce error,
  \casio attempts to identify the expressions that cause the error.
By looking at the error of each expression,
  \casio can determine which expressions
  have the most room for improvement.
However, expressions where children have high error
  usually have high error themselves.
To avoid biasing \casio's focusing algorithm
  toward larger expressions, \casio focuses
  based not on error, but on \emph{local error}.
Local error is defined at each operator
  as the error between
  the exact operator, applied to exactly-evaluated inputs
  and the inexact operator, applied to exactly-evaluated inputs;
  see Algorithm~\ref{alg:focus}.
By exactly evaluating inputs,
  \casio avoids penalizing the output of operators
  for errors in computing their inputs.

\casio computes the local error of every operator at every sample point,
  and ``focuses'' on the three expressions
  whose operators have the highest local error.
In many cases, this leads \casio to precisely identify the correct location
  to apply a rewrite.
For example, consider the program $\sqrt{x+1} - \sqrt{x}$.
This program is imprecise when $x$ is large,
  because $\sqrt{x+1}$ and $\sqrt{x}$ are large similar quantities,
  causing cancellation error.
For large inputs, both $\sqrt{x+1}$ and $\sqrt{x}$
  are computed with little error.
However, the subtraction, even with exact inputs,
  produces large errors due to cancellation.
Thus, the subtraction operator has high local error,
  while the other operators have very low error.
Upon analyzing this expression, 
  \casio identifies the subtraction as the location with the most local error,
  and ``focuses'' it's rewrites at that location.

\begin{figure}
\begin{align*}
  \|localerror| &: (\Var \to \RR) \to \Expr \to \NN \\
  \|localerror| &\:\Gamma\:c \ceq 1 \\
  \|localerror| &\:\Gamma\:x \ceq 1 \\
  \|localerror| &\:\Gamma\:f(e_1, e_2, \ldots, e_k) \ceq \\
  & e_i' \ceq \|eval|_\infty\:\Gamma\:e_i \\
  & r_{64} \ceq f_{64}\:(\F_{64}\:e_1')\:\ldots\:(\F_{64}:e_k') \\
  & r_\infty \ceq \F_{64}\:(f_\infty\:e_1'\:\ldots\:e_k') \\
  & \Err\:r_{64}\:r_\infty \\
\end{align*}
\caption{Computation of local error.
  Given a set of variable bindings and an expression,
  the local error evaluates all subexpressions in arbitrary precision and returns
  the difference between the arbitrary-precision and floating-point operators
  applied to this exact input.}
\label{alg:focus}
\end{figure}

\subsection{Recursive rewrite pattern matching}

After an expression is focused upon,
  \casio determines how to rewrite that expression.
A common problem is that an expression may require multiple rewrites
  to enable a rewrite that actually improves accuracy.
For example, consider the expression
\[
 \left(\frac{1}{x-1} - \frac{2}{x} \right) + \frac{1}{x+1}.
\]
\casio correctly identifies the $(+)$ operator
  to have the most local error (due to cancellation).
To improve the accuracy of this program,
  all of the fractions must be placed under a common denominator,
  and then the numerator must be simplified.
\casio has rules for fraction addition and subtraction;
  however, doing a single fraction addition or subtraction
  does not significantly change the accuracy of the program,
  since accuracy loss is caused by a cancellation
  that occurs when \emph{all} values are added together.
In order to improve the accuracy of this program,
  \casio must use the fraction addition/subtraction rules twice:
  once on the parenthesized subtraction,
  then again for the remaining addition.
Note that the first rewrite occurs not at the focused-upon operator,
  but on a child expression; however, this rewrite
  is necessary for enabling the later rewrite.

\casio uses a special pattern-matching algorithm
  to automatically find and solve instances like the above,
  where subexpressions must be rewritten
  to allow a rewrite of the parent expression.
Pseudo-code for this algorithm is sketched in Algorithm~\ref{alg:rm}.
This matching algorithm, which we call recursive rewrite pattern matching,
  allows \casio to automatically derive
  stretches of $n$ rewrites at once,
  where $n$ is the number of subexpressions present in the expression,
  although often the number of rewrites required is significantly less.

\begin{figure}
\begin{align*}
  \Pat &\ceq c | x | f(p_1, \dotsc, p_k) \\
  & c : \Expr, x : \Var_p, f : \Op, p_k : \Pat \\
  \mathbf{rules} &: (\Pat \times \Pat)\:\|set| \\
  \|match| &: \Pat \to \Expr \to (\Var_p \to \Expr) \\
  \|subst| &: \Pat \to (\Var_p \to \Expr) \to \Expr \\
  \\
  \|rr'| &: \Expr \to \Pat \to (\Expr \times (\Var_p \to Expr))\:\|set| \\
  \|rr'| &\:e\:e \ceq [ (e, \cdot) ] \\
  \|rr'| &\:e\:x' \ceq [ (e, x \mapsto e) ] \\
  \|rr'| &\:f(e_1, \dotsc, e_k)\:f(p_1, \dotsc, p_k) \ceq \\
  & \{ ( f(e_1', \dotsc, e_k'), \cup_i \Gamma_i) \I \\
  & \; (e_i', \Gamma_i) \in \|rr'|\:e_i\:p_i, \|compatible|\:\Gamma_i \} \\
  \|rr'| &\:f(e_1, \dotsc, e_k)\:f'(p_1, \dotsc, p_l) \ceq \\
  & \cup \{ \|rr'|\:(\|subst|\:b\:(\cup_i \Gamma_i))\:f'(p_1, \dotsc, p_l) \I \\
  & \quad (e_i', \Gamma_i) \in \|rr'|\:e_i\:a_i, \|compatible|\:\Gamma_i, \\
  & \quad (a, b) \in \mathbf{rules}, a \sim f(a_1, \dotsc, a_k) \} \\
  \\
  \|rr| &\:e\ceq \cup \{ \|rr'|\:e\:p \I (p, q) \in \mathbf{rules} \}
\end{align*}
\caption{Recrusive rewrite pattern matching.
  Given a set of from/to patterns in \textbf{rules}
  (which can be matched against and substituted into
  by \|match| and \|subst|),
  $(\|rr'|\:e\:p)$ returns a set of expressions
  each of which match the pattern $p$, and each of which is obtained from $e$
  by applying a sequence of rules from \textbf{rules},
  with at most one rule applied to any node in the expression tree.
  $(\|rr|\:e)$ returns the set of such rewritten expresisons for any pattern.}
\label{alg:rm}
\end{figure}

\subsection{Simplification}

In order to improve the accuracy of a formula,
  it is often necessary to first apply a rewrite rule
  at an expression of high error,
  and then cancel like terms and function inverses.
For example, \casio will rewrite $\sqrt{x+1} - \sqrt{x}$,
  into $(\sqrt{x+1}^2 - \sqrt{x}^2) / (\sqrt{x+1} + \sqrt{x})$.
On it's own, this transformation does not reduce error.
However, the numerator of this fraction simplifies to just $1$,
  and transforming the expression into $1/(\sqrt{x+1} + \sqrt{x})$
  does significantly reduce the error of the expression.
Therefore, to find such beneficial transformations,
  \casio automatically attempts to carry out such simplifications
  on every expression generated by the recursive matcher.
This simplification pass automatically
  removes function inverses such as $\sqrt{x}^2 \to x$,
  cancels like terms as in $x - x \to 0$,
  and combines terms as in $x + x \to 2x$.
These transformations would be nearly impossible to find
  by heuristics alone, 
  since they usually involve a long chain of reassociations and commutations;
  a separate simplification pass allows these transformations
  to be discovered easily.

\subsection{Storing Alternatives}

Between iterations of the core loop,
  \casio stores the set of programs
  that have the lowest error (of all generated candidates)
  at at least one of our evaluation points.
To update this set efficiently, \casio stores
  a map from points to a set of alternatives that do best at that point,
  and a map from alternatives to the points they do best at.
A candidate is added to this data structure
  only if it is better at some point
  than the alternatives currently stored for that point.
The alternatives that are no longer best at this point
  are removed from the data structure
  if there are no more points that they are best at.
This ensures that a minimal number of alternatives are stored.
This update rule is also biased toward keeping alternatives
  that were already contained in the table;
  this minimizes the amount of work that \casio does.

\subsection{Regime inference}

Often two real-equivalent programs have incomparable accuracy---%
  one performs better on some inputs, but worse on others.
A striking example of this phenomenon occurs with the expression $(e^x - 1) / x$.
The best program real-equivalent to the above
  uses the two implementations
\begin{align*}
  \frac{e^x - 1}{x} && \frac{e^x - 1}{\log e^x}
\end{align*}
  for different ranges of values for the variable $x$.
For x less than approximately $-0.5$, 
  and between -1e16 and 1e16,
  as well as values of x above .85,
  the former has better error behaviour.
For other values of x,
  the latter has better error behavior.
\casio must automatically infer the regimes
  into which the input subdivides,
  and must choose which programs to run on each region.
In doing this, \casio balances the cost of adding a branch
  against it's potential benefit,
  since each branch is computationally expensive.

\casio infers regimes using a dynamic programming algorithm.
First, \casio chooses a variable to infer regimes on
  (that is, regime inference works on one dimension at a time).
Then, it computes the best set of at most $k$ regimes
  for the region $(-\infty, t)$, where $t$ is a sampled point,
  with regimes $(t_0, t_1)$ evaluated by their total error
  in the region $t_0 < x < t_1$.
This is computed iteratively in $k$;
  to find the best set of up to $k$ regimes,
  for each possible $t_1$, each possible $t_0$ is considered,
  each regime $(t_0, t_1)$ is considered,
  and the best is added on to the best set of up to $k-1$ regimes
  (see Algorithm~\ref{sec:regimes}).
This algorithm runs in $O(n^2 k c)$ time,
  where $n$ is the number of points,
  $k$ is the maximum number of regimes,
  and $c$ is the number of candidate programs.
We have found this to be sufficiently fast,
  and this algorithm produces the optimal set of up to $k$ regimes.
Currently, the implementation of \casio limits $k$ to \nRegimes,
  since it is unlikely that producing more than 4 branches
  will improve error behavior enough to justify the added performance cost.
Once \casio has determined that branch should be placed
  between two of the sampled points,
  it uses a binary search across the chosen variable to 
  find the exact value to split on.

This regimes algorithm finds regimes that improve
  the accuracy of many of \casio's inputs.
Sometimes, like in the above example,
  significant improvements in accuracy simply cannot be achieved
  without the use of branches.
\casio's regime inference does this automatically
  and generates an appropriate branch condition.

\subsection{Periodic Functions}

Regimes inference works well when the regimes
  are large contiguous ranges of values for a particular variable.
Periodic functions, on the other hand, often require periodic regimes.
For example, the two real-equivalent formulas
\[
\frac{1 - \cos x}{\sin x} = \frac{\sin x}{1 + \cos x}
\]
  have low error on different ranges of values;
  the first has lower error near odd multiples of $\pi$,
  and the second has lower error near even multiples of $\pi$.
Regime inference cannot infer such regimes on it's own; furthermore,
  periodic functions can be evaluated more accurately
  if they are evaluated on points uniformly sampled in their period.
For these two reasons, \casio uses a static analysis
  to detect periodic functions, and analyze them specially.

To detect periodic functions, \casio uses an abstract interpretation,
  where each expression is classified as
  a constant (of known value); a linear function (of known coefficients);
  a periodic function (of known period); or a general function.
Addition, subtraction, multiplication, and division
  combine linear functions with each other or with constants
  into linear functions.
Trigonometric functions turn linear arguments
  into periodic outputs.
And any expression whose arguments are periodic
  is itself periodic, where the period is computed
  by taking the least common multiple of the periods of all children.
Expressions whose arguments include
  both periodic and non-periodic expressions
  are placed in the general class.
This analysis is conservative; for example, the period of $(\sin x)^2$
  is computed as $2 \pi$, whereas in fact it is $\pi$.
However, every expression that it declares as periodic
  is in fact periodic with the given period.

Once periodic functions have been found,
  \casio extracts the largest periodic expressions
  and executes a full \casio run on each expression,
  with points chosen uniformly on $[0, t)$,
  where $t$ is the period.
The result is then substituted back into the original program,
  with a caveat:
  if the result includes branches introduced by regime inference,
  each branch condition is modified to be periodic;
  that is, in the branch condition
  instances of a periodic variable $x$ with period $t$
  are substituted with $|mod|(x, t)$.
The program in each regime is not changed,
  because for large inputs, expressions such as
  $\sin \|mod|(x, 2\pi)$
  are less accurate than $\sin x$.

\subsection{Correlated Error}

Rewriting expressions where local error is high
  is usually the correct approach.
This is based on the assumption
  that the way to improve the accuracy of a program
  is to improve the accuracy of each expression in it.
In some cases, however, it is beneficial not to reduce the error in affected expression,
  but instead to introduce similar error in a sister expression,
  so that the the error in one expression
  cancels out the error in the other
  when the two expressions are combined.
A simple example of this approach,
  presented by William Kahan \todo{cite},
  is the formula $(e^x - 1) / x$.
This formula is inaccurate for $x$ near $0$,
  because cancellation occurs in $e^x - 1$.
However, if the denominator is transformed from $x$ into $\log e^x$,
  the same cancellation will occur in the denominator,
  leading to a result of approximately $1$, which is correct.

To utilize this technique,
  \casio will, after the main rewrite loop is complete,
  find all remaining expressions with error,
  and try rewrite sibling expressions, siblings of parents, and so on.
This produces many candidates, but since it is done only once
  and after the main rewrite loop is complete, the cost is small.
We've found this technique to be useful in only a small number of cases,
  but in many of those cases it is the only way to reduce error from that source.

\end{document}
