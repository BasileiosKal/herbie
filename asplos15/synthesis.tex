\documentclass[paper.tex]{subfiles}
\begin{document}

\section{Synthesis in \casio}

At a high level, \casio translates mathematical \emph{formulas}
  into floating-point \emph{programs}.
\casio translates using a heuristic search algorithm
  that attempts to find a sequence of changes
  that produces the largest improvement in precision.
Unlike conventional compilers,
  \casio is free to translate while changing
  the semantics of the translated program.

\subsection{Constraints on \casio}

Though \casio can change the answer produced by a program,
  it is not free to return arbitrary answers.
The main constraint on \casio
  is that, \emph{viewed as a real-number formula},
  the output of \casio must equal its input.
We can formalize this notion by defining
  two semantics for mathematical expressions:
  a real-number semantics,
  where each constant and variable is a real number
  and each operator a function from reals to reals;
  and a floating-point semantics,
  where each constant and variable is truncated
  to a floating-point number
  and where each function is replaced by its floating-point version.
Then we may require that \casio's transformations
  must preserve the real-number semantics of programs,
  though it may change their floating-point semantics.

In fact, this constraint is too strong,
  as it prevents transformations that change
  the region a program is defined on.
For example, output of the transformation
\[
  x + y \leadsto \frac{x^2 - y^2}{x - y}
\]
  is equal to its input, except where $x = y$.
For that particular input, the output program is not defined.
To allow this class of transformations,
  which can greatly improve the precision of a program,
  we require that the output program
  only equal the input program where both are defined.
We calls programs that are equal they are defined \emph{real-equivalent} programs.

This constraint that \casio only outputs real-equivalent programs
  influences \casio's architecture.
Since \casio must not change the real-number semantics of programs
  (except by changing where the program is defined),
  it is natural to structure \casio
  as applying a sequence of rewrite rules,
  each of which satisfy the above property.
These rules are specified by pattern matching;
  for example, the transformation above is a rule,
  with $x$ and $y$ matching arbitrary subexpressions.
\casio contains 109 rules,
  including those for
  the commutativity, associativity, distributivity, and identity
  of basic arithmetic operators;
  fraction arithmetic;
  laws of squares, square roots, exponents, and logarithms;
  and some basic facts of trigonometry.
Each of these rules is a basic fact of algebra;
  it incorporates no understanding of numerical methods.
In preparing the rules,
  care was taken to ensure that rules
  do not change the real-number semantics of programs.
This was usually easy, but required some care
  to avoid false ``identities'' such as $\sqrt{x^2} = x$
  (this identity being false for negative $x$).

The simplest method for improving precision
  would be to apply these rewrite rules at random,
  keeping more-precise variants.
This method does not work.
Too much time is spent on rewrites
  that have no effect on program precision.
Often, multiple rewrites without any effect
  are necessary to enable a rewrite that significantly improves precision.
The simplistic random-rewrite approach struggles with these cases.
To improve precision, important subexpressions
  must be found and focused on.

  \todo{Evaluating programs by sample points}

  \todo{Measuring error with floats-between}

\subsection{Focusing with local error}

\casio must focus on those expressions
  where a rewrite will effect the largest improvement in precision.
This measure must be approximated.
By looking at the error of each expression,
  \casio can determine which expressions
  have the most room for improvement.
However, expressions where children have high error
  usually have high error themselves by
  the garbage-in garbage-out principle.
To avoid biasing \casio's focusing algorithm
  toward larger expressions, \casio focuses
  based not on error, but on \emph{local error}.
Local error is defined at each operator
  as the error between
  the exact operator, applied to exactly-evaluated inputs
  and the inexact operator, applied to exactly-evaluated inputs;
  see Algorithm~\ref{alg:focus}.
By exactly evaluating inputs,
  \casio avoids penalizing the output of operators
  for errors in computing their inputs.

\casio computes the local error of every operator at every sample point,
  and chooses to focus on the three expressions
  whose operators have the highest local error.
In many cases, this leads \casio to precisely the correct location
  to apply a rewrite.
For example, consider the program $\sqrt{x+1} - \sqrt{x}$.
This program is imprecise when $x$ is large,
  because $\sqrt{x+1}$ and $\sqrt{x}$ are large and close-by,
  causing cancellation error.
For large inputs, both $\sqrt{x+1}$ and $\sqrt{x}$
  are computed with little error.
However, the subtraction, even with exact inputs,
  produces large errors due to cancellation.
Thus, the subtraction operator has high local error,
  while the other operators have very low error.
As a result, \casio easily finds the correct location
  to rewrite this program.

\subsection{Recursive rewrite pattern matching}

After an expression is focused upon,
  \casio must determine how to rewrite that expression.
A common problem is that an expression may require multiple rewrites
  to enable a rewrite that actually improves precision.
For example, consider the expression
\[
 \left(\frac{1}{x-1} - \frac{2}{x} \right) + \frac{1}{x+1}.
\]
\casio correctly identifies the $(+)$ operator
  to have the most local error (due to cancellation).
To improve the precision of this program,
  all of the fractions must be placed under a common denominator,
  and then the numerator must be simplified.
\casio has rules for fraction addition and subtraction;
  however, doing a single fraction addition or subtraction
  does not significantly change the precision of the program,
  since precision loss is caused by a cancellation
  that occurs when \emph{all} values are added together.
In order to improve the precision of this program,
  \casio must use the fraction addition/subtraction rules twice:
  once on the parenthesized subtraction,
  then again for the remaining addition.
Note that the first rewrite occurs not at the focused-upon operator,
  but on a child expression; however, this rewrite
  is necessary for enabling the later rewrite.

\casio uses a special pattern-matching algorithm
  to automatically find and solve instances like the above,
  where subexpressions must be rewritten
  to allow a rewrite of the parent expression.
Pseudo-code for this algorithm is sketched in Algorithm~\ref{alg:rm}.
This matching algorithm, which we call recursive rewrite pattern matching,
  allows \casio to automatically derive
  stretches of \todo{How many} rewrites at once.
\casio uses recursive-rewrite pattern matching
  after focusing on an expression.

\end{document}
