\documentclass[paper.tex]{subfiles}
\begin{document}

\section{Synthesis in \casio}
\label{sec:synthesis}

At a high level, \casio translates mathematical \emph{formulas}
  into floating-point \emph{programs}.
\casio accomplishes this translation using a heuristic search algorithm
  that attempts to find a sequence of changes
  that produces the largest improvement in precision.
Unlike conventional compilers,
  \casio is free to translate while changing
  the semantics of the translated program.

\subsection{Constraints on \casio}

Though \casio can change the answer produced by a program,
  it is not free to return arbitrary answers.
The main constraint on \casio
  is that, \emph{viewed as a real-number formula},
  the output of \casio must equal its input.
We can formalize this notion by defining
  two semantics for mathematical expressions:
  a real-number semantics,
  where each constant and variable is a real number
  and each operator a function from reals to reals;
  and a floating-point semantics,
  where each constant and variable is truncated
  to a floating-point number
  and where each function is replaced by its floating-point version.
Then we may require that \casio's transformations
  must preserve the real-number semantics of programs,
  though it may change their floating-point semantics.

In fact, this constraint is too strong,
  as it prevents transformations that change
  the region a program is defined on.
For example, output of the transformation
\[
  x + y \leadsto \frac{x^2 - y^2}{x - y}
\]
  is equal to its input, except where $x = y$.
For that particular input, the output program is not defined.
To allow this class of transformations,
  which can greatly improve the precision of a program,
  we require that the output program
  only equal the input program where both are defined.
We call programs that are equal they are defined \emph{real-equivalent} programs.

Since \casio must not change the real-number semantics of programs
  (except by changing where the program is defined),
  it is natural to structure \casio
  as applying a sequence of rewrite rules,
  each of which satisfy the above property.
These rules are specified as input and output patterns;
  for example, the transformation above is a rule,
  with $x$ and $y$ matching arbitrary subexpressions.
\casio contains 122 rules,
  including those for
  the commutativity, associativity, distributivity, and identity
  of basic arithmetic operators;
  fraction arithmetic;
  laws of squares, square roots, exponents, and logarithms;
  and some basic facts of trigonometry.
Each of these rules is a basic fact of algebra;
  it incorporates no understanding of numerical methods.
In preparing the rules,
  care was taken to ensure that rules
  do not change the real-number semantics of programs.
This was usually easy, but required some care
  to avoid false ``identities'' such as $\sqrt{x^2} = x$
  (this identity being false for negative $x$).

The simplest, most obvious approach to a rewrite based system
  is a hill-climbing brute force search,
  where one applies rewrite rules at random,
  keeping the transformations where error behavior is improved.
Unfortunately, this method is not effective:
  too much time is spent on rewrites
  that have no effect on program precision,
  and sequences of rewrites that would improve precision
  are often not found, since intermediary steps do not neccessarily improve error.
Often, multiple rewrites without any effect
  are necessary to enable a rewrite that significantly improves precision.
Sometimes, even after the correct rewrite is found,
  terms need to be canceled before precision is gained.
The simplistic random-rewrite approach struggles with these cases.
To improve precision, important subexpressions
  must be found and focused on;
  sequences of rewrites need to be considered as a unit;
  and cancellation needs to occur automatically.

\casio's core is a simple loop
  which threads together several rewrite techniques,
  each described below.
The loop tracks a set of \emph{alternatives},
  each a program real-equivalent to the input.
This set of alternatives only contains
  programs that have the lowest error on at least one point
  of all candidate programs generated so far.
In each iteration, \casio generates new candidates
  by choosing one alternative that has not been chosen before;
  finding expressions where a rewrite may lead improvement;
  selecting the rewrite-rules which match the error-causing operator
  and applying a sequence of rewrites to enable the application of that rule;
  and simplifying the result, canceling like terms.
Then the best candidate is chosen for the next iteration.
Before entering the main loop,
  \casio analyzes the program for periodic subexpressions
  and attempts to optimize them separately.
After the main loop completes,
  \casio aggregates all candidates generated
  throughout the course of the loop,
  and infers regimes of input values for which
  to execute different candidates.
Together, these techniques make up \casio.

\begin{figure}
\begin{align*}
  \|start| &\:e\ceq \\
  & pts, exs \ceq \|pickPoints|\:e \\
  & e' \ceq \|simplify|\:e \\
  & e'' \ceq \|mapPeriod|\;e'\;\|main-loop| \\
  & t \ceq \|makeTable|\;e''\\
  & \|loop|\:t\\
  \\
  \|loop| &\:t\:\ceq \\
  & \mathbf{if}\:t.\|done|\:\mathbf{then}\:\|finish|\:t\:\mathbf{else} \\
  & e, t' \ceq \|pick|\;t \\
  & es \ceq \|map|\:\|simplify|\:(\|map|\:\|rr|\:(\|focus|\;e)) \\
  & \|loop|\:(t' + es) \\
  \\
  \|finish| &\;t \ceq \\
  & \|regimes|\:(\cup\{\|uncorrelated|\;e \I e \in t \})
\end{align*}

\end{figure}

\subsection{Evaluating error of expressions}

As \casio discovers and applies rewrites,
  it needs to know if it is improving precision.
This can be done statically using interval~\cite{} or affine arithmetic~\cite{},
  or using an SMT solver to get tighter bounds~\cite{}.
However, affine and interval arithmetic give
  very conservative estimates of error~\cite{},
  and SMT techniques are slow.
Instead, \casio estimates error by simply sampling many possible inputs
  and computing the average difference between a floating-point
  and arbitrary-precision evaluation on those points.
Arbitrary-precision arithmetic is slow,
  so arbitrary-precision results are computed only once per run;
  each rewrite need only be evaluated in floating-point
  and compared to the already-computed arbitrary-precision results.
\casio selects 500 points, distributed approximately uniformly
  over the \emph{set} of floating-point numbers
  (this leads to a near-uniform distribution over the exponent).
While it may seem intuitive to instead select points
  distributed near-uniform over the reals instead,
  there are several problems with this approach:
firstly, we found during evaluation
  that distributing uniformly across the reals
  yields only points of the upper two or three orders of magnitude,
  which for some functions produces results
  that are unilaterally out of bounds of floating points;
secondly, even for functions that have reasonable results for large input values,
  sampling only these large exponents yields to a misrepresentative error evaluation.
Experiments show that the estimate computed from 500 points
  is rarely more than one bit of error removed from the true answer.

Once sample points are chosen
  and exact and floating-point answers are computed,
  some measure of error is necessary to compare the two.
Mathematically-natural measures include absolute and relative error.
However, both of these measures are ill-suited
  to measuring error between floating-point values~\cite{}.
We follow \textsc{Stoke}~\cite{} in defining the error between $x$ and $y$
  by the number of floating-point values in the range $[x, y]$.
This measure of error is uniform over the input space,
  avoiding problems with denormal floating-point values,
  and avoiding any special handling for infinities.
Casio evaluates the input program in arbitrary precision at every sample point,
  and casting the result to floating point; this is the exact solution.
Any candidate program can then be evaluated in floating point
  and compared to the exact solution at that point,
  to compute the candidate program's error at that point.

\begin{figure}
\begin{align*}
  \FP_{64}, \FP_\infty &: \|FloatingPointSystem| \\
  \Err &\:x\:y \ceq \#\{ z : \FP_{64}\:|\:x \le z \le y \} \\
  \\
  \Var &\ceq \{ x, y, z, \dotsc \} \\
  \Op &\ceq \{ \|exp|, \|pow|, \|log|, \dotsc \} \\
  \Expr &\ceq c \I x \I f(e_1, \dotsc, e_k) \\
  & c : \RR, x : \Var, f : \Op, e_i : \Expr \\
  \|eval|_t &: (\Var \to \RR) \to \Expr \to \FP_t
\end{align*}
\caption{Common variables. $\FP_{64}$ and $\FP_\infty$ represent
  the types of 64-bit floating point and arbitrary-precision values.
  $\Err$ measures the error between two real values
  as the number of floating point values between them.
  $\Expr$ represents the type of mathematical expressions,
  and $\|eval|_t$ evaluates expressions in $\FP_t$ arithmetic.}
\label{alg:defs}
\end{figure}

\subsection{Focusing with local error}

In order to most effectively apply rewrites that reduce error,
  \casio attempts to identity the expressions that cause the error.
By looking at the error of each expression,
  \casio can determine which expressions
  have the most room for improvement.
However, expressions where children have high error
  usually have high error themselves by
  the garbage-in garbage-out principle.
To avoid biasing \casio's focusing algorithm
  toward larger expressions, \casio focuses
  based not on error, but on \emph{local error}.
Local error is defined at each operator
  as the error between
  the exact operator, applied to exactly-evaluated inputs
  and the inexact operator, applied to exactly-evaluated inputs;
  see Algorithm~\ref{alg:focus}.
By exactly evaluating inputs,
  \casio avoids penalizing the output of operators
  for errors in computing their inputs.

\casio computes the local error of every operator at every sample point,
  and ``focuses'' on the three expressions
  whose operators have the highest local error.
In many cases, this leads \casio to precisely the correct location
  to apply a rewrite.
For example, consider the program $\sqrt{x+1} - \sqrt{x}$.
This program is imprecise when $x$ is large,
  because $\sqrt{x+1}$ and $\sqrt{x}$ are large similar quantities,
  causing cancellation error.
For large inputs, both $\sqrt{x+1}$ and $\sqrt{x}$
  are computed with little error.
However, the subtraction, even with exact inputs,
  produces large errors due to cancellation.
Thus, the subtraction operator has high local error,
  while the other operators have very low error.
Upon analyzing this expression, 
  \casio identifies the subtraction as the location with the most local error,
  and ``focuses'' it's rewrites at that location.

\begin{figure}
\begin{align*}
  \|localerror| &: (\Var \to \RR) \to \Expr \to \NN \\
  \|localerror| &\:\Gamma\:c \ceq 1 \\
  \|localerror| &\:\Gamma\:x \ceq 1 \\
  \|localerror| &\:\Gamma\:f(e_1, e_2, \ldots, e_k) \ceq \\
  & e_i' \ceq \|eval|_\infty\:\Gamma\:e_i \\
  & r_{64} \ceq f_{64}\:(\F_{64}\:e_1')\:\ldots\:(\F_{64}:e_k') \\
  & r_\infty \ceq \F_{64}\:(f_\infty\:e_1'\:\ldots\:e_k') \\
  & \Err\:r_{64}\:r_\infty \\
\end{align*}
\caption{Computation of local error.
  Given a set of variable bindings and an expression,
  the local error evaluates all subexpressions in arbitrary precision and returns
  the difference between the arbitrary-precision and floating-point operators
  applied to this exact input.}
\label{alg:focus}
\end{figure}

\subsection{Recursive rewrite pattern matching}

After an expression is focused upon,
  \casio determines how to rewrite that expression.
A common problem is that an expression may require multiple rewrites
  to enable a rewrite that actually improves precision.
For example, consider the expression
\[
 \left(\frac{1}{x-1} - \frac{2}{x} \right) + \frac{1}{x+1}.
\]
\casio correctly identifies the $(+)$ operator
  to have the most local error (due to cancellation).
To improve the precision of this program,
  all of the fractions must be placed under a common denominator,
  and then the numerator must be simplified.
\casio has rules for fraction addition and subtraction;
  however, doing a single fraction addition or subtraction
  does not significantly change the precision of the program,
  since precision loss is caused by a cancellation
  that occurs when \emph{all} values are added together.
In order to improve the precision of this program,
  \casio must use the fraction addition/subtraction rules twice:
  once on the parenthesized subtraction,
  then again for the remaining addition.
Note that the first rewrite occurs not at the focused-upon operator,
  but on a child expression; however, this rewrite
  is necessary for enabling the later rewrite.

\casio uses a special pattern-matching algorithm
  to automatically find and solve instances like the above,
  where subexpressions must be rewritten
  to allow a rewrite of the parent expression.
Pseudo-code for this algorithm is sketched in Algorithm~\ref{alg:rm}.
This matching algorithm, which we call recursive rewrite pattern matching,
  allows \casio to automatically derive
  stretches of \todo{How many} rewrites at once.
\casio uses recursive-rewrite pattern matching
  after focusing on an expression.

\begin{figure}
\begin{align*}
  \Pat &\ceq c | x | f(p_1, \dotsc, p_k) \\
  & c : \Expr, x : \Var_p, f : \Op, p_k : \Pat \\
  \mathbf{rules} &: (\Pat \times \Pat)\:\|set| \\
  \|match| &: \Pat \to \Expr \to (\Var_p \to \Expr) \\
  \|subst| &: \Pat \to (\Var_p \to \Expr) \to \Expr \\
  \\
  \|rr'| &: \Expr \to \Pat \to (\Expr \times (\Var_p \to Expr))\:\|set| \\
  \|rr'| &\:e\:e \ceq [ (e, \cdot) ] \\
  \|rr'| &\:e\:x' \ceq [ (e, x \mapsto e) ] \\
  \|rr'| &\:f(e_1, \dotsc, e_k)\:f(p_1, \dotsc, p_k) \ceq \\
  & \{ ( f(e_1', \dotsc, e_k'), \cup_i \Gamma_i) \I \\
  & \; (e_i', \Gamma_i) \in \|rr'|\:e_i\:p_i, \|compatible|\:\Gamma_i \} \\
  \|rr'| &\:f(e_1, \dotsc, e_k)\:f'(p_1, \dotsc, p_l) \ceq \\
  & \cup \{ \|rr'|\:(\|subst|\:b\:(\cup_i \Gamma_i))\:f'(p_1, \dotsc, p_l) \I \\
  & \quad (e_i', \Gamma_i) \in \|rr'|\:e_i\:a_i, \|compatible|\:\Gamma_i, \\
  & \quad (a, b) \in \mathbf{rules}, a \sim f(a_1, \dotsc, a_k) \} \\
  \\
  \|rr| &\:e\ceq \cup \{ \|rr'|\:e\:p \I (p, q) \in \mathbf{rules} \}
\end{align*}
\caption{Recrusive rewrite pattern matching.
  Given a set of from/to patterns in \textbf{rules}
  (which can be matched against and substituted into
  by \|match| and \|subst|),
  $(\|rr'|\:e\:p)$ returns a set of expressions
  each of which match the pattern $p$, and each of which is obtained from $e$
  by applying a sequence of rules from \textbf{rules},
  with at most one rule applied to any node in the expression tree.
  $(\|rr|\:e)$ returns the set of such rewritten expresisons for any pattern.}
\label{alg:rm}
\end{figure}

\subsection{Simplification}

In improving the precision of a formula,
  \casio will often generate intermediate expressions in which terms cancel.
For example, \casio will rewrite $\sqrt{x+1} - \sqrt{x}$,
  into $(\sqrt{x+1}^2 - \sqrt{x}^2) / (\sqrt{x+1} + \sqrt{x})$.
The numerator of this fraction simplifies to just $1$;
  this simplification is necessary to give an accurate answer.
\casio must automatically carry out such simplifications.
This simplification pass automatically
  removes expressions such as $\sqrt{x}^2$,
  cancels like terms as in $x - x$,
  and combines terms as in $x + x$.
Automatically discovering
  the reassociation of additions and subtractions that allows a cancellation
  is difficult by heuristics alone;
  thus a separate simplification pass is necessary.

\subsection{Storing Alternatives}

Between iterations of the core loop,
  \casio stores the set of programs
  that have the lowest error (of all generated candidates)
  at at least one point.
To update this set efficiently, \casio stores
  a map from points to a set of alternatives that do best at that point,
  and a map from alternatives to the points they do best at.
A candidate is added to this data structure
  only if it is better at some point
  than the alternatives currently stored for that point.
The alternatives that are no longer best at this point
  are removed from the data structure
  if there are no more points that they are best at.
This ensures that a minimal number of alternatives are stored.
This update rule is also biased toward keeping alternatives
  that were already focused and rewritten;
  this minimizes the amount of work that \casio does.

\subsection{Regime inference}

Often two real-equivalent programs have incomparable precision---%
  one performs better on some inputs, but worse on others.
A striking example of this phenomenon occurs with the expression $(e^x - 1) / x$.
The best program real-equivalent to the above
  uses the three implementations
\begin{align*}
  \frac{e^x - 1}{x} && \frac{e^x - 1}{\log e^x} &&
  \frac{e^x}{x} - \frac1x && \frac{e^x - 1}{\sqrt{x}^2} 
\end{align*}
  each for different ranges of values for the variable $x$.
\casio must automatically infer the regimes
  into which the input subdivides,
  and must choose which programs to run on each region.
In doing this, \casio must not find too many regimes,
  since each branch is computationally expensive.

\casio infers regimes using a dynamic programming algorithm.
First, \casio chooses a variable to infer regimes on
  (that is, regime inference works on one dimension at a time).
Then, it computes the best set of at most $k$ regimes
  for the region $(-\infty, t)$, where $t$ is a sampled point,
  with regimes $(t_0, t_1)$ evaluated by their total error
  in the region $t_0 < x < t_1$.
This is computed iteratively in $k$;
  to find the best set of up to $k$ regimes,
  for each possible $t_1$, each possible $t_0$ is considered,
  each regime $(t_0, t_1)$ is considered,
  and the best is added on to the best set of up to $k-1$ regimes
  (see Algorithm~\ref{sec:regimes}).
This algorithm runs in $O(n^2 k c)$ time,
  where $n$ is the number of points,
  $k$ is the maximum number of regimes,
  and $c$ is the number of candidate programs.
We have found this to be sufficiently fast;
  this algorithm produces the optimal set of up to $k$ regimes.
\casio caps $k$ at 5.
Regime endpoints are chosen to be between sampled points;
  to determine where exactly the split point between regimes should go,
  \casio uses a binary search on that variable.

This regimes algorithm finds regimes that improve
  the precision of many of \casio's inputs.
Sometimes, like in the above example,
  finding regimes is necessary to achieve
  a significant improvement in precision.
\casio's regime inference does this automatically
  and generates an appropriate branch condition.

\subsection{Periodic Functions}

Regimes inference works well when the regimes
  are large contiguous ranges in a variable.
Periodic functions, on the other hand, often require periodic regimes.
For example, the two real-equivalent formulas
\[
\frac{1 - \cos x}{\sin x} = \frac{\sin x}{1 + \cos x}
\]
  need regimes, wherein the second will be used
  near even multiples of $\pi$, and the first near odd multiples.
Regime inference cannot infer such regimes; furthermore,
  periodic functions can be evaluated more accurately
  if they are evaluated on points uniformly sampled in their period.
For these two reasons, \casio uses a static analysis
  to detect periodic functions, and analyze them specially.

To detect periodic functions, \casio uses an abstract interpretation,
  where each expression is classified as
  a constant (of known value); a linear function (of known coefficients);
  a periodic function (of known period); or a general function.
Addition, subtraction, multiplication, and division
  combine linear functions with each other or with constants
  into linear functions.
Trigonometric functions turn linear arguments
  into periodic outputs.
And any expression whose arguments are periodic
  is itself periodic, where the period is computed
  by taking the least common multiple of the periods of all children.
Expressions whose arguments include
  both periodic and non-periodic expressions
  are placed in the general class.
This analysis is conservative; for example, the period of $(\sin x)^2$
  is computed as $2 \pi$, whereas in fact it is $\pi$.
However, every expression that it declares as periodic
  is in fact periodic with the given period.

Once periodic functions have been found,
  \casio extracts the largest periodic expressions
  and executes a full \casio run on each expression,
  with points chosen uniformly on $[0, t)$,
  where $t$ is the period.
If the resulting program includes branches introduced by regime inference,
  each branch condition is changed by the substitution
  $x \mapsto \|mod|(x, t)$, for each variable $x$ with period $t$.
The program in each regime is not changed,
  because for large inputs, expressions such as
  $\sin \|mod|(x, 2\pi)$
  are less accurate than $\sin x$.

\subsection{Correlated Error}

\casio's focusing mechanism usually correctly detects
  the best expression to rewrite.
However, it is based on an assumption:
  that the way to improve the precision of a program
  is to improve the precision of each expression in it.
This assumption ignores the possibility
  that two expressions could both have error,
  but error that correlates and somehow cancels
  when the two expressions are combined.
A case where this occurs is the formula $(e^x - 1) / x$.
This formula is inaccurate for $x$ near $0$,
  because cancellation occurs in $e^x - 1$.
However, if the denominator is transformed from $x$ into $\log e^x$,
  the same cancellation will occur in the denominator,
  leading to a result of approximately $1$, which is correct.

To support this type of precision optimization,
  \casio will, after the main rewrite loop is complete,
  find all remaining expressions with error,
  and try rewrite sibling expressions, siblings of parents, and so on.
This produces many candidates, but since it is done only once
  and after the main rewrite loop is complete, the cost is small.
We've found this optimization to be useful in only a small number of cases.

\end{document}
