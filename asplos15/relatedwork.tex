\documentclass[paper.tex]{subfiles}
\begin{document}

\section{Related Work}
\label{sec:relatedwork}

\casio builds upon decades of work in numerical analysis
  and recent advances in the analysis
  of floating point computations.

\paragraph{Numerical analysis}

Numerical analysis analyzes mathematical computations
  performed by computers.
It includes a vast literature on how to evaluate mathematical functions.
The technique of rearranging formulas
  appears in surveys~\cite{acm91-every-scientist,berkeley00-needle-like},
  and in common textbooks~\cite{book87-nmse}.
\casio uses the techniques invented in this literature,
  but rearranges formulas automatically, avoiding the need for an expert.

It is difficult to know the working precision necessary
  to accurately evaluate a function,
  a problem known as the table maker's dilemma~\cite{ensl03-table-maker}.
Recent work on this problem allowed the creation of MPFR,
  an arbitrary-precision floating point library
  which correctly rounds exponential, trigonometric, and other basic functions~\cite{acm07-mpfr}.
However, composing these functions can still lead to error.
\casio uses MPFR internally to determine
  the exact output of a computation,
  to compare candidate programs for accuracy.

\paragraph{Verification}

Floating point computation is defined in the IEEE~754
  standard~\cite{ieee85-standard,ieee08-standard}.
This standard specifies the behavior
  for floating point numbers and their primitive operations.
However, programming languages often
  do not require adherence to this standard.
For example, C~\cite{c99} allows intermediate results
  to be computed in extended precision,
  and only truncated when stored into memory~\cite{toplas08-pitfalls-verifying}.
This makes verification and analysis difficult
  for floating point computations.

Recent work in the program verification community
  has allowed formal verification of numerical programs.
The triangle area computation discussed by Kahan~\cite{berkeley00-needle-like},
  for example, was proven accurate by S.~Boldo
  in the interactive proof assistant Coq~\cite{arith13-area-triangle}.
Larger computations---%
  programs for computing discriminants~\cite{ieee09-discriminant-proven}
  or solving simple partial differential equations~\cite{jar13-wave-equation-prove}---%
  have also been proven correct.
Automatic proofs have been also explored:
  Rosa~\cite{popl14-rosa} provides a language for specifying accuracy requirements
  and uses an SMT solver to automatically prove them.
Ariadne~\cite{popl13-ariadne} applies SMT
  to detect inputs which cause floating point overflow.
\casio focuses on the problem of floating point accuracy, not overflow;
  if verification is required, tools like Rosa could be used
  to prove that the output of \casio is sufficiently accurate.

\paragraph{Optimization of floating point programs}
The Stoke super-optimizer supports
  optimizing floating point programs while guaranteeing
  that the resulting accuracy is acceptable~\cite{pldi14-stoke}.
Stoke uses a stochastic search over assembly programs
  to find faster implementations of a given function,
  without introducing unacceptable error
  relative to the original program.
A similar tool is Precimonious~\cite{sc13-precimonious},
  which attempts to decrease the precision of intermediate results
  to improve performance.
Both tools assume that the input program they are given
  accurately represents the computation the program intended to perform.
If the input program is inaccurate, Stoke and Precimonious can at best guarantee
  that the accuracy of the optimized result is not much worse.
On the other hand, \casio attempts to improve the input program,
  so that it better represents
  the real number formula that it implements.
We suspect that Stoke and \casio may complement each other,
  with \casio improving the accuracy of a program,
  so that its error (relative to a real number computation) is acceptable,
  and Stoke then optimizing the program within the given error bounds.

\end{document}
