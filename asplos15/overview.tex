\documentclass[paper.tex]{subfiles}
\begin{document}

\section{Overview}
\label{sec:overview}

Given the complexities of error in floating point computation,
  producing the minimal-error program
  for a given real number formula
  seems out of reach%
  \footnote{\cite{} show it this task to be NP-hard}.
Instead, \casio performs a heuristic search over programs,
  aiming for minimal error.
\casio's search proceeds by applying local program transformations.
Each transformation corresponds to a identity of real number formulas,
  but does not necessarily preserve the semantics of the program
  as evaluated with floating-point operators.
\casio contains 119 rules,
  most describing basic arithmetic facts
  such as the commutativity of addition,
  others demonstrating trigonometric facts
  such as the sine and cosine angle addition identities.

\casio's heuristic search is organized by two core ideas:
  high-level and domain-specific strategies
  that apply goal-directed rewrite rules;
  and pursuing different programs
  for different parts of the input space.
\casio encodes goal-directed rewrites in its
  focusing, recursive-rewrite, and simplification systems.
To pursue different programs for different inputs, \casio uses
  candidate tables, branch inference, and periodicity analysis.
These two core ideas combine the better parts
  of brute-force and targetted search.
By applying high-level strategies,
  \casio gains the speed and domain-specificity of targetted search.
But like brute-force search,
  \casio pursue strategies in parallel, selecting whichever works best.

To demonstrate the method by which
  \casio improves the precision of floating point programs,
  this section steps through \casio as run on the formula
\begin{equation}\label{eq:ex}
  \frac1{\sqrt2} \sqrt{\sqrt{x^2 + y^2} + x},
\end{equation}
  which computes the real part of $\sqrt{x + i y}$.
This forumla is imprecise for negative $x$,
  especially if $x$ is large and $y$ is small.
Improving the precision of this formula
  involves most of the major systems;
  each of \casio's major systems is described in detail
  in Section~\ref{sec:synthesis}.

\casio begins the process of improving~\eqref{eq:ex}
  by identifying subexpressions
  which likely need transformation.
The imprecision arises from the addition $\sqrt{x^2 + y^2} + x$:
  for negative $x$,
  the two summands are approximately equal in magnitude,
  leading to a cancellation.
\casio notices this same fact
  by analyzing the behavior of the program on sample inputs.
For each expression in the program,
  \casio computes the exact value of its children
  using arbitrary-precision arithmetic.
A \emph{locally approximate} result is then computed
  by applying a floating-point operator to exact arguments.
By comparing this locally approximate result to the exact result,
  \casio obtains a measure of how much each operator
  contributed to the expression's overall error.
For the complex square root example,
  the addition $\sqrt{x^2 + y^2} + x$ produces the most local error
  for large negative values of $x$.
This information is passed to \casio's recursive rewrite step,
  directing rewrites toward improving a particular expression.

Once problematic expressions are identified,
  local transformations are applied at that expression.
\casio's uses a recursive rewrite algorithm for doing this:
  if a rewrite rule does not apply,
  children of the expressions are recursively rewritten
  in an attempt to make the rule match.
This rewrite step produces several candidate programs
  for each expression focused upon.
For example, rewriting at the addition discussed above
  produces seven candidate programs;
  two other expressions with nonzero local error produce 17 more.
Of these, one candidate applies the identity
  $x + y = (x^2 - y^2) / (x - y)$ to the problematic addition.
This transforms \eqref{eq:ex} into
\begin{equation} \label{eq:ex2}
  \frac1{\sqrt2} \sqrt{\frac{\sqrt{x^2 + y^2}^2 - x^2}{\sqrt{x^2 + y^2} - x}}.
\end{equation}
This candidate does not have improved precision,
  but it does introduce the possibility
  of cancelling the two $x^2$ terms.

To discover this cancellation,
  \casio cannot use focusing and recursive rewrite
  because there are too many intermediate steps:
  removing the unnecessary $\sqrt{-}^2$,
  commuting the addition $x^2 + y^2$,
  and reassociating the subtraction $(y^2 + x^2) - x^2$.
Discovering such a long sequence of undirected steps
  by enumerating all sequences of rewrites
  would take too long.
Instead, \casio has a simplification pass
  specialized toward cancelling like terms.
Simplification automatically performs all the steps necessary
  to transform the candidate~\eqref{eq:ex2} into
\begin{equation} \label{eq:ex3}
  \frac1{\sqrt2} \sqrt{\frac{y^2}{\sqrt{x^2 + y^2} - x}}.
\end{equation}
This new program has no imprecision for negative $x$,
  but it is imprecise for positive $x$.
Branch inference is now used to combine both programs
  into one that is precise for all $x$.

In this example, as in many,
  no single branch-free program is precise for all input values.
To compute a formula precisely, the data must select
  which program to use for the formula's evaluation.
\casio's branch inference system
  computes the branch condition
  that selects between several programs depending on the input data.
Branch inference creates this condition
  by considering all generated programs
  that are best on at least one sample point,
  and then using the sample points to divide each input variable
  into several regions, with one program per region.
In the case of programs \eqref{eq:ex} and \eqref{eq:ex3},
  branch inference correctly decides
  to use \eqref{eq:ex} for positive values of $x$
  and \eqref{eq:ex3} for negative values.
The final program produced by \casio is
\[
\begin{cases}
  \frac1{\sqrt2} \sqrt{\sqrt{x^2 + y^2} + x} & x \ge 0 \\
  \frac1{\sqrt2} \sqrt{\frac{y^2}{\sqrt{x^2 + y^2} - x}} & x < 0 \\
\end{cases}
\]

This example was drawn from a open-source mathematics library.
However, most numerical programs are not library functions
  but are instead simulations or data analysis scripts
  used by scientists, engineers, and mathematicians
  in the course of their work.
The expressions encountered in these programs are more complex
  and less structured than examples like~\eqref{eq:ex}.
\casio has demonstrated success in improving precision
  in these more-difficult cases.
A colleague of ours had difficulties with the numerical precision
  of a estimator in a machine learning task.
He needed to compute the expression
  \todo{Harley's equation here}
  and found that the simple encoding of this formula as a program
  lead to spurious results and violated invariants in later code.
Our estimates suggests that this simple encoding produces
  as many as thirty bits of error, averaged over floating point values.
To avoid these problems,
  our colleague manually manipulated the expression
  into a form that seemed not to cause similar problems;
  our estimates suggest that this improved variant
  had 10 bits of average error.

Upon hearing of his troubles,
  we fed the original, simple implementation to \casio.
\casio produced a program with 4 bits average error:
  \todo{Our better version of Harley's program}.
\casio obviated the need for manual algebraic manipulation,
  and produce superior results with no manual steps.
We have found the produced program difficult to understand,
  and our attempts to simplify it
  have lead to greatly increasing its error.
By properly targetting its search,
  \casio is able to consider more likely alternatives
  than human analysts are able to,
  and produced better results.

\end{document}
