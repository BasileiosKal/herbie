\documentclass[paper.tex]{subfiles}
\begin{document}

\section{Overview}
\label{sec:overview}

Given the complexities of error in floating point computation,
  producing the minimal-error program
  for a given real number formula
  is impractical
  \footnote{\cite{} show it this task to be NP-hard}.
Instead, \casio performs a heuristic search over programs,
  aiming for minimal error.
Instead of attempting to transform the whole program,
  \casio's search proceeds by applying local program transformations.
Each transformation corresponds to a identity of real number formulas,
  but does not necessarily preserve the semantics of the program
  as evaluated with floating-point operators.
\casio contains 122 rewrite rules,
  most describing basic arithmetic facts
  such as the commutativity of addition,
  others demonstrating trigonometric facts
  such as the sine and cosine angle addition identities.

\casio's heuristic search is organized by two core ideas:
  high-level and domain-specific strategies
  that apply goal-directed rewrite rules;
  and pursuing different programs
  for different parts of the input space.
At each step of it's goal directed search,
  \casio focuses on expressions with high error,
  uses it's recursive-rewriter to destruct the operator of that expression,
  and them simplifies the expression.
To pursue different programs for different inputs,
  \casio holds on to all potentially relevant alts in candidate tables,
  combines incomparable candidates using regime inference,
  and analyzes periodic subexpressions for periodic regime boundries.
These two core ideas combine the better parts
  of brute-force and targeted search.
By applying high-level strategies,
  \casio is able to explore deeply into the search space
  without running into exponential slowdown.
But like brute-force search,
  \casio pursues multiple alternative transformations in parallel, 
  selecting whichever produces the best result.

To demonstrate the method by which
  \casio improves the precision of floating point programs,
  this section steps through \casio as run on the formula
\begin{equation}\label{eq:ex}
  \frac1{\sqrt2} \sqrt{\sqrt{x^2 + y^2} + x},
\end{equation}
  which computes the real part of $\sqrt{x + i y}$.
This forumla is imprecise for negative $x$,
  especially if $x$ is large and $y$ is small.
Improving the precision of this formula
  involves most of the major systems;
  each of these systems is described in detail
  in Section~\ref{sec:synthesis}.

\casio begins the process of improving~\eqref{eq:ex}
  by identifying subexpressions
  which likely need transformation.
The imprecision arises from the addition $\sqrt{x^2 + y^2} + x$:
  for negative $x$, and a small $y$,
  the two summands are approximately equal in magnitude,
  leading to a cancellation.
\casio notices this same fact
  by analyzing the behavior of the program on sample inputs.
For each expression in the program,
  \casio computes the exact value of its children
  using arbitrary-precision arithmetic.
A \emph{locally approximate} result is then computed
  by applying a floating-point operator to exact arguments.
By comparing this locally approximate result to the exact result,
  \casio obtains a measure of how much each operator
  contributed to the expression's overall error.
For the complex square root example,
  the addition $\sqrt{x^2 + y^2} + x$ produces the most local error
  for large negative values of $x$.
This information is passed to \casio's recursive rewrite step,
  directing rewrites toward improving this particular expression.

Once problematic expressions are identified,
  local transformations are applied at that expression.
\casio uses a recursive rewrite algorithm for doing this:
  if a rewrite rule does not immediately pattern match on the expression,
  but destructs the correct operator,
  and matches the number of arguments,
  the children of the expression are recursively rewritten
  in an attempt to make the rule match.
This rewrite step produces several candidate programs
  for each expression focused upon.
For example, rewriting at the addition discussed above
  produces seven candidate programs;
  two other expressions with nonzero local error produce 17 more.
Of these, one candidate applies the identity
  $x + y = (x^2 - y^2) / (x - y)$ to the problematic addition.
This transforms \eqref{eq:ex} into
\begin{equation} \label{eq:ex2}
  \frac1{\sqrt2} \sqrt{\frac{\sqrt{x^2 + y^2}^2 - x^2}{\sqrt{x^2 + y^2} - x}}.
\end{equation}
This candidate does not have improved precision,
  but it does introduce the possibility
  of cancelling the two $x^2$ terms.

To discover this cancellation,
  \casio cannot use focusing and recursive rewrite
  because there are too many intermediate steps:
  removing the unnecessary $\sqrt{-}^2$,
  commuting the addition $x^2 + y^2$,
  and reassociating the subtraction $(y^2 + x^2) - x^2$.
Discovering such a long sequence of undirected steps
  by enumerating all sequences of rewrites
  would take too long.
Instead, \casio has a simplification pass
  specialized toward cancelling like terms.
Simplification automatically performs all the steps necessary
  to transform the candidate~\eqref{eq:ex2} into
\begin{equation} \label{eq:ex3}
  \frac1{\sqrt2} \sqrt{\frac{y^2}{\sqrt{x^2 + y^2} - x}}.
\end{equation}
This new program has no imprecision for negative $x$,
  but it is imprecise for positive $x$.
Regime inference will now be used to combine both programs
  into one that is precise for all $x$.

In this example, as in many,
  no single-regime program is precise for all input values.
To compute a formula precisely, the data must select
  which program to use for the formula's evaluation.
\casio's regime inference system
  computes the branch condition
  that selects between several programs depending on the input data.
Regime inference creates this condition
  by considering all generated programs
  that are best on at least one sample point,
  and then using the sample points to divide each input variable
  into several regions, with one program per region,
  although some programs may cover multiple non-adjacent regions.
In the case of programs \eqref{eq:ex} and \eqref{eq:ex3},
  regime inference correctly decides
  to use \eqref{eq:ex} for positive values of $x$
  and \eqref{eq:ex3} for negative values.
The final program produced by \casio is
\[
\begin{cases}
  \frac1{\sqrt2} \sqrt{\sqrt{x^2 + y^2} + x} & x \ge 0 \\
  \frac1{\sqrt2} \sqrt{\frac{y^2}{\sqrt{x^2 + y^2} - x}} & x < 0 \\
\end{cases}
\]

The preceding example was drawn from a open-source mathematics library.
However, most numerical programs are not library functions
  but are instead simulations or data analysis scripts
  used by scientists, engineers, and mathematicians
  in the course of their work.
The expressions encountered in these programs are more complex
  and less structured than examples like~\eqref{eq:ex}.
\casio has demonstrated success in improving precision
  in these more-difficult cases.
A colleague of ours had difficulties with the numerical precision
  of a estimator in a machine learning task.
He needed to compute the expression
\begin{align*}
\mathsf{ans} &= \frac{p(e_-,e_+|s)}{p(e_-,e_+|t)} \\
p(e_-, e_+|x) &= (\operatorname{sig} x)^{e_+} (1 - \operatorname{sig} x)^{e_-} \\
\operatorname{sig}x &= 1 / (1 - e^{-x})
\end{align*}
  and found that the simple encoding of this formula as a program
  lead to spurious results and violated invariants in later code.
Our estimates suggests that this simple encoding produces
  seventeen bits of error, averaged over floating point values.
To avoid these problems,
  our colleague manually manipulated the expression
  into a form that seemed not to cause similar problems;
  our estimates suggest that this improved variant
  had ten bits of average error.

Upon hearing of his troubles,
  we fed the original, simple implementation to \casio.
\casio produced a program with four bits average error:
  \begin{equation*}
  \operatorname{exp}\left(e_+\ln{\frac{1+e^{-t}}{1+e^{-s}}} +
     e_-\ln{\frac{1-\frac{1}{1+e^{-s}}}
                 {1-\frac{1}{1+e^{-t}}}}\right)
  \end{equation*}
\casio obviated the need for manual algebraic manipulation,
  and produced superior results with no manual steps.
The low-error program that \casio produced was of a complexity level
  such that human analysts would be unlikely to reproduce the result. 
Furthermore, our attempts to simplify the program
  into a form more likely to be found by human analysts
  have only been able to do so by greatly increasing it's error.
By properly targetting its search,
  \casio is able to consider a greater number of viable alternatives
  than human analysts are able to,
  and is capable of producing better results.

\end{document}
