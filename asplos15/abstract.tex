\documentclass[paper.tex]{subfiles}
\begin{document}

\begin{abstract}

  From scientific computing to finance, many applications depend on
  hardware-supported floating point arithmetic. Developers of these
  applications typically use floating point to efficiently approximate
  computation over real numbers.  Unfortunately, this approximation
  introduces rounding error, which can compound to produce completely
  incorrect results.  If the largest hardware-supported precision
  cannot produce sufficiently accurate results, developers may be
  forced to incur the costs of simulating arbitrary precision floating
  point in software.  While the numerical methods literature provides
  techniques to mitigate rounding error without increasing precision,
  manually applying these techniques requires substantial expertise.

  We introduce \casio, an automated technique to mitigate rounding
  error without resorting to software floating point.  Given a real
  number formula, \casio combines three novel techniques to search for
  a floating point implementation that improves accuracy: (1) an
  approach to estimating error and its causes which is tailored to
  managing the high branching factor of \casio's search; (2) an
  approach to detecting regimes where error behavior changes, allowing
  \casio to combine multiple programs and reduce overall error; (3) a
  technique that iteratively applies local, domain specific rewrites,
  from which traditional error-reducing program transformations fall
  out naturally. We evaluate \casio on benchmarks drawn from numerical
  methods textbooks, mathematical libraries, and recent scientific
  articles, demonstrating that \casio substantially reduces error
  while imposing modest overhead.

\end{abstract}

% Furthermore, such incorrect results are difficult to
%   detect and debug. 

% ideal real number computation

  % The numerical methods literature provides techniques to mitigate
  % rounding error.  Unfortunately, manually applying these techniques
  % requires substantial expertise.  In practice, developers often
  % address rounding error by increasing precision at the cost of
  % performance and memory usage.  However, once the largest
  % hardware-supported precision has been reached, the developer
  % typically has few tools to reduce rounding error while keeping all
  % floating point operations in hardware.

%   Floating point computation is a well known approach to approximating real
% computation in the bounded context of practical hardware.  Recent advances
% provide techniques to trade-off accuracy for improved speed and power usage
% at the cost of precision.  However, this work is often carried out under
% the assumption that the original floating program is the ``ground truth'',
% that is, that it is already an acceptable approximation of the original
% real computation the programmer had in mind.  Unfortunately, approximating
% real computation in floating point presents many subtle challenges which,
% if not accounted for, can yield arbitrarily large errors.  This limits the
% value of recent advances improving the runtime and power efficiency of such
% computations: the wrong answer is simply arrived at more quickly using
% fewer joules (watts? ugh).

% The field of numerical methods provides a rich set of techniques for
% improving the numerical accuracy and precision of real computations
% approximated in floating point.  Unfortunately, applying these techniques
% has traditionally demanded extensive training and expensive manual analysis
% and optimization of numerical programs.  As more and more scientists write
% numerical programs, this lack of accuracy becomes increasingly troubling.
% These non-expert programmers usually lack the training and time necessary
% to employ numerical methods in their code, and often may not even be aware
% of the subtle challenges this domain presents.

% We present a new tool, \casio, which synthesizes floating point programs
% which better approximate the real computations programmers have in mind.
% Casio works by performing a heuristic search over the space of programs
% equivalent to the input program over the reals.  Each step of the search
% attempts to apply identity transformations over the reals that have been
% shown valuable in the numerical methods literature.  Casio also searches
% for alternate representations of programs that may be challenging for even
% for numerical methods experts to develop, for example, special casing
% variants of the program to input domains with better precision for that
% variant.

% We evaluate \casio on a number of examples drawn from numerical methods
% textbooks, scientific journal articles, and math libraries.  We find that
% \casio is often able to improve the precision of these examples
% considerably.

\end{document}
